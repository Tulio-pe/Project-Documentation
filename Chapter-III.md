# Capítulo III: Requirements Specification

## 3.1. To-Be Scenario Mapping
>Segmento 1

<img src="./src/To-Be_segmento1.png " alt="To-Be_segmento1" style="display: block; margin: 50px auto 0 auto;"/> 

>Segmento 2

<img src="./src/To-be_segmento2.png " alt="To-be_segmento2" style="display: block; margin: 50px auto 0 auto;"/> 

## 3.2. User Stories
This section provides a collection of user stories that describe the functionalities and features from the end-user perspective.

## Épicas - Sistema de Gestión de Talleres

## E01 - Gestión de Cuentas y Autenticación
**Descripción:** Como gestor de taller, necesito un sistema completo de autenticación que me permita registrarme, iniciar sesión, mantener mi perfil actualizado y cerrar sesión de forma segura, para acceder de manera controlada a todas las funcionalidades de la plataforma.

**Objetivo:** Proporcionar un sistema seguro y confiable de gestión de cuentas de usuario para los gestores de taller.

**Criterios de Aceptación:**
- Sistema de registro con validación de datos únicos
- Actualización de perfil personal
- Cierre de sesión seguro con invalidación de tokens

---

## E02 - Gestión de Información del Taller
**Descripción:** Como gestor de taller, necesito poder registrar, mantener y actualizar toda la información básica de mi taller, incluyendo datos de contacto, ubicación y horarios de atención, para que los clientes puedan encontrarme y conocer mi disponibilidad.

**Objetivo:** Permitir a los gestores mantener actualizada la información completa de su taller en la plataforma.

**Criterios de Aceptación:**
- Registro completo de información del taller con validaciones
- Edición de datos del taller
- Configuración de horarios regulares por días de la semana
- Actualización de horarios de atención

---

## E03 - Búsqueda y Visualización de Talleres (Conductores)
**Descripción:** Como conductor, necesito poder buscar talleres cercanos utilizando filtros geográficos y ver información detallada de cada uno, incluyendo sus datos de contacto y horarios, para elegir el taller que mejor se adapte a mis necesidades y ubicación.

**Objetivo:** Facilitar a los conductores la búsqueda y selección de talleres mediante una interfaz intuitiva con filtros geográficos.

**Criterios de Aceptación:**
- Filtrado por ubicación 
- Listado de talleres con información resumida
- Vista detallada de cada taller con información completa
- Integración con WhatsApp para contacto directo

---

## E04 - Gestión de Vehículos
**Descripción:** Como gestor de taller, necesito registrar y mantener un catálogo de vehículos de mis clientes con sus datos técnicos, para poder asociarlos posteriormente a órdenes de reparación y llevar un control organizado del trabajo.

**Objetivo:** Proporcionar un sistema de gestión de vehículos que sirva como base para las órdenes de reparación.

**Criterios de Aceptación:**
- Registro de vehículos con validación de placas únicas
- Listado de vehículos registrados por taller
- Asociación directa con órdenes de reparación

---

## E05 - Gestión de Órdenes de Reparación
**Descripción:** Como gestor de taller, necesito crear y gestionar órdenes de reparación para cada vehículo, controlando su estado a través de un flujo definido (Por revisar → En revisión → Revisado → Entregado), para llevar un seguimiento ordenado del trabajo y proporcionar información actualizada a los clientes.

**Objetivo:** Implementar un sistema completo de gestión de órdenes de reparación con seguimiento de estados.

**Criterios de Aceptación:**
- Creación de órdenes con códigos únicos
- Gestión de estados con flujo controlado
- Filtrado de órdenes por estado
- Control de órdenes abiertas por vehículo

---

## E06 - Seguimiento de Reparaciones (Conductores)
**Descripción:** Como conductor, necesito poder consultar el estado actual de la reparación de mi vehículo utilizando un código de seguimiento, para estar informado del progreso sin necesidad de contactar directamente al taller.

**Objetivo:** Ofrecer transparencia y comunicación efectiva sobre el estado de las reparaciones a los conductores.

**Criterios de Aceptación:**
- Consulta por código de seguimiento
- Visualización completa del estado y detalles de la reparación
- Información del vehículo y taller
- Opción de contacto directo con el taller

## Historias de Usuario

| Epic/User Story ID | Título | Descripción | Criterios de Aceptación | Relacionado con (Epic ID) |
|--------------------|--------|-------------|-------------------------|---------------------------|
| US01 | Registrar cuenta de gestor | Como gestor de taller, quiero registrarme en la plataforma, para obtener una cuenta que me permita acceder a mis funciones. | **Scenario:** Registro exitoso de gestor<br>**Given** el gestor está en el formulario "Registro"<br>**When** completa email, firstname, lastname, username y password (≥ 6 caracteres)<br>**And** el email y el username no existen en la base de datos<br>**And** pulsa "Registrarse"<br>**Then** el sistema guarda la cuenta con la contraseña encriptada (bcrypt)<br>**And** redirige al inicio de sesión | E01 |
| US02 | Iniciar sesión | Como gestor de taller, quiero iniciar sesión con mis credenciales, para acceder a la plataforma. | **Scenario:** Inicio de sesión válido<br>**Given** el gestor está en la pantalla "Login"<br>**When** ingresa email y password correctos<br>**Then** el sistema emite un JWT<br>**And** redirige al dashboard u onboarding según corresponda<br><br>**Scenario:** Inicio de sesión inválido<br>**Given** el gestor está en la pantalla "Login"<br>**When** ingresa email o password incorrectos<br>**Then** el sistema muestra "Credenciales inválidas"<br>**And** permanece en la misma pantalla | E01 |
| US03 | Actualizar perfil personal | Como gestor de taller, quiero actualizar mis datos personales, para mantener mi información al día. | **Scenario:** Actualización exitosa del perfil<br>**Given** el gestor está autenticado y en "Mi perfil"<br>**When** modifica firstname, lastname o username (dejando email y password sin cambios)<br>**And** el nuevo username no existe en otro usuario<br>**And** pulsa "Guardar"<br>**Then** el sistema actualiza los datos en la base de datos<br>**And** muestra el mensaje "Datos actualizados" | E01 |
| US04 | Cerrar sesión | Como gestor de taller, quiero cerrar sesión, para finalizar mi acceso de forma segura. | **Scenario:** Cierre de sesión<br>**Given** el gestor está autenticado en la plataforma<br>**When** pulsa "Cerrar sesión"<br>**Then** el sistema invalida el JWT actual<br>**And** redirige al inicio de sesión<br>**And** muestra "Sesión cerrada" | E01 |
| US05 | Registrar información del taller | Como gestor de taller, quiero registrar la información básica de mi taller, para que aparezca en la plataforma y los clientes puedan encontrarlo. | **Scenario:** Registro exitoso del taller<br>**Given** el gestor está en el formulario "Registrar taller"<br>**When** completa photo (png/jpg), address, email, name, phone, description y selecciona ubicación Región → Provincia → Distrito → Ciudad<br>**And** el email tiene formato válido y todos los campos son obligatorios<br>**Then** el sistema guarda la ficha del taller en la BD<br>**And** muestra el mensaje "Taller registrado" | E02 |
| US06 | Editar información del taller | Como gestor de taller, quiero editar la información básica de mi taller cuando cambie, para mantener en la plataforma datos siempre correctos y actualizados. | **Scenario:** Actualización de datos del taller<br>**Given** el gestor abre la pantalla "Editar taller" y los campos se autocompletan<br>**When** modifica photo, address, description, email, name, phone o ubicación (cascada Región → Provincia → Distrito → Ciudad)<br>**And** pulsa "Guardar"<br>**Then** el sistema actualiza la información del taller en la BD<br>**And** muestra el mensaje "Taller actualizado" | E02 |
| US07 | Configurar horarios regulares | Como gestor de taller, quiero configurar los días y horarios regulares de atención de mi taller, para que los clientes sepan cuándo pueden agendar una cita. | **Scenario:** Definir horarios iniciales<br>**Given** el gestor está en la sección "Horarios"<br>**When** añade entradas para cada día de la semana con StartTime y EndTime válidos (StartTime < EndTime, ≤ 24 h)<br>**And** puede marcar un día como "No atiende" mediante Enabled = false<br>**Then** el sistema guarda la lista completa en la BD<br>**And** muestra confirmación de guardado | E02 |
| US08 | Actualizar horarios de atención | Como gestor de taller, quiero actualizar los días y horarios de atención cuando cambien, para mantener la información siempre al día. | **Scenario:** Edición de horarios existentes<br>**Given** el gestor abre "Editar horarios" y las entradas existentes se cargan<br>**When** modifica StartTime, EndTime, Enabled o añade/elimina días<br>**And** pulsa "Guardar"<br>**Then** el sistema persiste los cambios en la BD<br>**And** muestra el mensaje "Horarios actualizados" | E02 |
| US09 | Explorar talleres filtrados | Como conductor, quiero explorar una lista de talleres filtrada por región → provincia → distrito → ciudad (o por mi ubicación actual), para encontrar rápidamente uno cercano. | **Scenario:** Filtrar por ciudad y listar talleres<br>**Given** el conductor está en la pantalla "Explorar talleres"<br>**When** no ha seleccionado aún la cascada completa Región → Provincia → Distrito → Ciudad<br>**Then** el sistema muestra "Selecciona tu ciudad para ver talleres disponibles"<br><br>**Scenario:** Mostrar resultados de la ciudad seleccionada<br>**Given** el conductor selecciona una ciudad válida en el filtro<br>**When** la API devuelve talleres de esa ciudad<br>**Then** el sistema muestra cards con photo miniatura, name, short description, address y botón "Ver más"<br><br>**Scenario:** Sin talleres en la ciudad<br>**Given** el conductor selecciona una ciudad sin talleres<br>**Then** el sistema muestra "No se encontraron talleres en esta ubicación" | E03 |
| US10 | Ver detalle de taller | Como conductor, quiero ver la ficha detallada de un taller seleccionado, para decidir si se ajusta a mis necesidades. | **Scenario:** Visualizar detalle y contactar<br>**Given** el conductor está en la lista de talleres filtrados<br>**When** pulsa el botón "Ver más" de un taller<br>**Then** se abre la página de detalle del taller con photo grande, name, description extendida, address, email, phone<br>**And** se listan los horarios (DayOfWeek, Start–End, Enabled)<br>**And** hay un botón "Contactar" que abre https://wa.me/&lt;phone&gt; en nueva pestaña<br>**And** un enlace "← Volver" regresa al listado conservando el filtro<br>**And** si algún campo está vacío se muestra "Información no disponible" | E03 |
| US11 | Registrar vehículo | Como gestor de taller, quiero registrar un vehículo de cliente (carBrand, carModel, fuelType, licensePlate, year), para poder asociarlo luego a órdenes de reparación. | **Scenario:** Registro exitoso de vehículo<br>**Given** el gestor está en el formulario "Registrar vehículo"<br>**When** completa carBrand, carModel, fuelType, licensePlate y year (1980 – año actual)<br>**And** la placa no existe en otro vehículo del taller<br>**Then** el sistema guarda el vehículo en la BD<br>**And** muestra "Vehículo registrado" | E04 |
| US12 | Listar vehículos del taller | Como gestor de taller, quiero listar mis vehículos registrados, para ver rápidamente los que ya están cargados o crear uno nuevo. | **Scenario:** Sin vehículos registrados<br>**Given** el gestor accede a "Mis vehículos"<br>**And** no hay vehículos en la BD<br>**Then** el sistema muestra "Aún no tienes vehículos registrados" y un botón "Registrar vehículo"<br><br>**Scenario:** Con vehículos registrados<br>**Given** existen vehículos asociados al taller<br>**Then** el sistema muestra cards con carBrand, carModel, licensePlate, year y color (si existe), cada una con botón "Crear reparación" | E04 |
| US13 | Crear orden de reparación | Como gestor de taller, quiero crear una orden de reparación a partir de un vehículo, para llevar el control del trabajo. | **Scenario:** Creación de reparación cuando no existe una abierta<br>**Given** el gestor visualiza un vehículo sin reparaciones abiertas<br>**When** pulsa "Crear reparación"<br>**Then** el sistema genera *repairCode* = *licensePlate-NN* (correlativo por vehículo)<br>**And** crea la reparación con estado inicial "Por revisar" y *updatedAt* actual<br><br>**Scenario:** Reparación abierta impide una nueva<br>**Given** el vehículo ya tiene una reparación no entregada<br>**Then** el botón "Crear reparación" aparece deshabilitado<br>**And** muestra el tooltip "Ya existe una reparación abierta" | E05 |
| US14 | Cambiar estado de reparación | Como gestor de taller, quiero cambiar el estado de una reparación entre Por revisar → En revisión → Revisado → Entregado, para reflejar su avance. | **Scenario:** Avanzar al siguiente estado<br>**Given** el gestor está en la orden con estado actual *S* (donde *S* ≠ "Entregado")<br>**When** selecciona avanzar al siguiente estado permitido<br>**Then** el sistema actualiza el estado<br>**And** registra la fecha y hora en *updatedAt*<br><br>**Scenario:** Cerrar reparación al marcar "Entregado"<br>**Given** la reparación está en estado "Revisado"<br>**When** el gestor marca "Entregado"<br>**Then** la reparación queda cerrada<br>**And** el botón "Crear reparación" se habilita de nuevo para ese vehículo | E05 |
| US15 | Filtrar reparaciones por estado | Como gestor de taller, quiero filtrar mis reparaciones por estado, para ver rápidamente qué autos requieren atención. | **Scenario:** Filtrar reparaciones exitosamente<br>**Given** el gestor está en la vista de reparaciones y elige un estado (Por revisar, En revisión, Revisado, Entregado, Todas)<br>**When** selecciona el estado<br>**Then** la lista se actualiza en ≤ 1 s mostrando solo las reparaciones que coinciden<br><br>**Scenario:** Sin reparaciones para el estado elegido<br>**Given** el gestor selecciona un estado sin coincidencias<br>**Then** el sistema muestra "Sin resultados" | E05 |
| US16 | Tracking de reparación (conductor) | Como conductor, quiero ingresar el código de seguimiento (repairCode) que me dio el taller, para conocer el estado de la reparación de mi vehículo. | **Scenario:** Código válido<br>**Given** el conductor está en la pantalla "Tracking"<br>**When** ingresa un *repairCode* existente en formato *LICENSE-NN*<br>**Then** el sistema redirige a la vista Detalle de reparación<br><br>**Scenario:** Código inexistente<br>**Given** el conductor está en la pantalla "Tracking"<br>**When** ingresa un *repairCode* que no existe<br>**Then** el sistema muestra "Código no encontrado" | E06 |
| US17 | Ver detalle de reparación | Como conductor, quiero ver el estado actual y los detalles de mi reparación, para estar informado sin llamar ni visitar el taller. | **Scenario:** Visualizar detalles de la reparación<br>**Given** el conductor accede a la página de detalle usando un *repairCode* válido<br>**Then** el sistema muestra:<br> • Estado (Por revisar / En revisión / Revisado / Entregado)<br> • *UpdatedAt* (fecha y hora de la última actualización)<br> • Datos del vehículo: *carBrand, carModel, fuelType, licensePlate, year*<br> • Datos del taller: *name, dirección completa, ciudad/distrito*<br>**And** presenta un botón "Contactar taller" que abre `https://wa.me/<phone>` en nueva pestaña<br>**And** si el estado es "Entregado", se destaca con un icono/etiqueta verde y el botón de contacto permanece disponible | E06 |
| TS01 | Implementar Sistema de Autenticación Basado en JWT | Como desarrollador, quiero implementar un sistema de autenticación robusto basado en JWT, para asegurar las sesiones de los usuarios y proteger la comunicación entre el frontend y el backend, garantizando que solo usuarios autorizados accedan a recursos protegidos. | **Scenario:** Generación exitosa de JWT al iniciar sesión<br>**Given** un usuario ha proporcionado credenciales válidas<br>**When** el usuario intenta iniciar sesión<br>**Then** el sistema debe generar un JWT válido<br>**And** el sistema debe devolver el JWT al cliente<br><br>**Scenario:** Validación de JWT en solicitudes a endpoints protegidos<br>**Given** un usuario tiene un JWT válido<br>**When** el usuario realiza una solicitud a un endpoint protegido incluyendo el JWT<br>**Then** el sistema debe validar el JWT correctamente<br>**And** debe permitir el acceso al recurso<br><br>**Scenario:** Manejo de JWT inválido o ausente<br>**Given** una solicitud a un endpoint protegido<br>**When** el JWT es inválido o está ausente<br>**Then** el sistema debe devolver un código de estado 401 (Unauthorized)<br><br>**Scenario:** Manejo de expiración de JWT<br>**Given** un usuario con un JWT que ha expirado<br>**When** el usuario realiza una solicitud a un endpoint protegido<br>**Then** el sistema debe requerir una nueva autenticación o un token de refresco (si aplica)<br><br>**Scenario:** Almacenamiento seguro de JWT en el cliente<br>**Given** un JWT válido<br>**When** el JWT se envía al cliente<br>**Then** debe almacenarse siguiendo las mejores prácticas de seguridad (e.g., consideraciones de localStorage, sessionStorage, o HttpOnly cookies) |  |
| TS02 | Implementar Hashing de Contraseñas con Bcrypt | Como desarrollador, quiero implementar el algoritmo de hashing Bcrypt para las contraseñas de los usuarios, para garantizar su seguridad en la base de datos y proteger contra ataques de fuerza bruta o exposición de datos en texto plano. | **Scenario:** Hashing de contraseñas durante el registro<br>**Given** un nuevo usuario proporciona una contraseña<br>**When** la contraseña se guarda en la base de datos<br>**Then** la contraseña debe ser hasheada usando Bcrypt con un "salt" único y aleatorio<br><br>**Scenario:** Verificación de contraseñas durante el inicio de sesión<br>**Given** un usuario proporciona una contraseña para iniciar sesión<br>**When** el sistema verifica la contraseña<br>**Then** el sistema debe usar la función de verificación de Bcrypt para comparar la contraseña con el hash almacenado<br>**And** el inicio de sesión debe ser exitoso si la comparación coincide, o fallar si no | TS-002 |
| TS03 | Establecer un Sistema Centralizado de Logging y Monitoreo de Errores | Como desarrollador, quiero establecer un sistema centralizado de logging y monitoreo de errores, para facilitar la depuración, mejorar la visibilidad del rendimiento de la aplicación e identificar proactivamente cualquier problema en producción. | **Scenario:** Registro automático de errores<br>**Given** ocurre un error en cualquier capa de la aplicación (backend, frontend)<br>**When** el error es capturado por el sistema de logging<br>**Then** debe registrarse con la fecha/hora, el tipo de error y el stack trace completo<br><br>**Scenario:** Generación de logs informativos<br>**Given** se realiza una acción clave (e.g., inicio de sesión, registro, creación de cita)<br>**When** la acción se completa<br>**Then** debe generarse un log informativo con los detalles relevantes<br><br>**Scenario:** Configuración de niveles de logging<br>**Given** un entorno de aplicación<br>**When** se configura el nivel de logging (DEBUG, INFO, WARN, ERROR)<br>**Then** el sistema solo debe registrar los mensajes que cumplan o superen ese nivel<br><br>**Scenario:** Acceso a los logs<br>**Given** un desarrollador o miembro de operaciones<br>**When** necesita depurar o monitorear el sistema<br>**Then** los logs deben ser fácilmente accesibles y legibles | TS03 |
| TS04 | Implementar Validaciones de Datos Robustas en el Backend | Como desarrollador, quiero implementar validaciones de datos robustas en el backend, para mantener la integridad de la información del sistema y protegerlo de entradas maliciosas o incorrectas que puedan comprometer la seguridad o funcionalidad. | **Scenario:** Validación de tipos de datos y formatos<br>**Given** una solicitud entrante con datos del usuario<br>**When** el backend procesa los datos<br>**Then** todos los campos deben ser validados por su tipo de dato, formato (e.g., email válido, número entero) y restricciones de longitud/rango<br><br>**Scenario:** Manejo de datos inválidos<br>**Given** una solicitud con datos que no cumplen las validaciones<br>**When** el backend recibe la solicitud<br>**Then** debe devolver un código de estado 400 Bad Request<br>**And** la respuesta debe incluir mensajes de error claros y específicos que indiquen qué campos fallaron la validación<br><br>**Scenario:** Prevención de ataques de inyección<br>**Given** una entrada de usuario potencialmente maliciosa (e.g., con scripts HTML, caracteres SQL)<br>**When** la entrada es procesada por el backend<br>**Then** las validaciones deben sanitizar o rechazar la entrada para prevenir ataques de inyección (SQL, XSS)<br><br>**Scenario:** Verificación de campos obligatorios<br>**Given** una solicitud que omite un campo marcado como obligatorio<br>**When** el backend recibe la solicitud<br>**Then** debe devolver un error indicando que el campo obligatorio está ausente |  |
| TS05 | Configurar Gestión Segura de Variables de Entorno | Como desarrollador, quiero configurar un sistema seguro para la gestión de variables de entorno, para evitar la exposición de credenciales y claves sensibles en el código fuente y permitir una configuración flexible entre distintos entornos (desarrollo, staging, producción). | **Scenario:** Carga de credenciales en producción<br>**Given** la aplicación se despliega en un entorno de producción<br>**When** la aplicación se inicia<br>**Then** las credenciales de la base de datos, claves de JWT y otras claves de API deben ser cargadas desde variables de entorno del sistema operativo o un gestor de secretos<br><br>**Scenario:** Uso de .env en desarrollo<br>**Given** un desarrollador trabaja en el entorno local<br>**When** la aplicación se ejecuta localmente<br>**Then** debe cargar las variables de entorno desde un archivo .env que no esté versionado en Git<br><br>**Scenario:** Ausencia de secretos hardcodeados<br>**Given** el código fuente de la aplicación<br>**When** se revisa el código<br>**Then** ninguna credencial sensible o secreto debe estar hardcodeado directamente en el código | |
| TS06 | Diseñar y Configurar la Base de Datos Relacional (PostgreSQL) | Como desarrollador, quiero diseñar el esquema de la base de datos y configurarla usando PostgreSQL, para almacenar de manera eficiente, segura y escalable toda la información del negocio, como usuarios, talleres, citas y reparaciones. | **Scenario:** Diseño y creación del esquema de la base de datos<br>**Given** el inicio del desarrollo del proyecto<br>**When** se define la estructura de datos<br>**Then** el esquema de la base de datos debe estar diseñado con tablas claras para Usuarios, Talleres, Citas, Mantenimientos, etc.<br><br>**Scenario:** Establecimiento de relaciones entre tablas<br>**Given** las tablas de la base de datos<br>**When** se definen las relaciones entre ellas<br>**Then** deben establecerse correctamente las claves primarias y foráneas para asegurar la integridad referencial<br><br>**Scenario:** Optimización del rendimiento de consultas<br>**Given** la identificación de consultas que serán frecuentes (e.g., búsqueda de talleres, listar citas)<br>**When** se optimiza el esquema<br>**Then** se deben crear índices apropiados en los campos clave para mejorar el rendimiento de estas consultas<br><br>**Scenario:** Conexión segura a la base de datos<br>**Given** la aplicación intenta conectarse a la base de datos<br>**When** la conexión se establece<br>**Then** debe ser segura (e.g., uso de credenciales separadas, conexión cifrada si el entorno lo requiere) y configurable |  |
| TS07 | Desarrollar API RESTful para la Gestión de Usuarios | Como desarrollador, quiero desarrollar los endpoints del API RESTful para la gestión de usuarios, para permitir a los usuarios registrarse, iniciar sesión, y gestionar su información de perfil de forma programática y segura, sirviendo como la interfaz principal para estas funcionalidades. | **Scenario:** Registro de nuevos usuarios<br>**Given** se envía una solicitud POST a /api/register con los datos de un nuevo usuario<br>**When** los datos son válidos<br>**Then** el sistema debe crear el usuario y devolver un código de estado 201 Created<br><br>**Scenario:** Inicio de sesión de usuarios existentes<br>**Given** se envía una solicitud POST a /api/login con credenciales válidas<br>**When** las credenciales son correctas<br>**Then** el sistema debe devolver un JWT y un código de estado 200 OK<br><br>**Scenario:** Obtención del perfil de usuario<br>**Given** un usuario autenticado<br>**When** se envía una solicitud GET a /api/users/{id}<br>**Then** el sistema debe devolver los detalles del perfil del usuario correspondiente con un código 200 OK<br><br>**Scenario:** Actualización del perfil de usuario<br>**Given** un usuario autenticado con permisos para modificar su perfil<br>**When** se envía una solicitud PUT a /api/users/{id} con datos actualizados<br>**Then** el sistema debe actualizar el perfil del usuario y devolver un 200 OK<br><br>**Scenario:** Eliminación del perfil de usuario<br>**Given** un usuario autenticado con permisos para eliminar su perfil<br>**When** se envía una solicitud DELETE a /api/users/{id}<br>**Then** el sistema debe eliminar el perfil del usuario y devolver un 204 No Content<br><br>**Scenario:** Formato de comunicación API<br>**Given** cualquier solicitud o respuesta a estos endpoints<br>**Then** deben manejar el formato JSON<br><br>**Scenario:** Uso de códigos de estado HTTP apropiados<br>**Given** cualquier operación en estos endpoints<br>**Then** el sistema debe devolver los códigos de estado HTTP estándar (e.g., 400 Bad Request, 401 Unauthorized, 404 Not Found, 500 Internal Server Error) según el resultado | TS07 |
| TS08 | Desarrollar API RESTful para la Gestión de Talleres y Citas | Como desarrollador, quiero implementar los endpoints del API RESTful para la gestión de talleres y citas, para permitir a los usuarios buscar talleres, solicitar citas y gestionar sus citas existentes de manera programática. | **Scenario:** Búsqueda de talleres<br>**Given** se envía una solicitud GET a /api/workshops<br>**When** se incluyen parámetros de filtro (e.g., ubicación, especialidad)<br>**Then** el sistema debe devolver una lista de talleres que coincidan con los criterios<br><br>**Scenario:** Obtención de detalles de un taller específico<br>**Given** se envía una solicitud GET a /api/workshops/{id}<br>**When** el id del taller es válido<br>**Then** el sistema debe devolver los detalles completos del taller<br><br>**Scenario:** Solicitud de una nueva cita<br>**Given** un usuario autenticado<br>**When** se envía una solicitud POST a /api/appointments con los detalles de la cita (taller, fecha, hora, vehículo, etc.)<br>**Then** el sistema debe crear la nueva cita y devolver un 201 Created<br><br>**Scenario:** Listado de citas de un usuario<br>**Given** un usuario autenticado<br>**When** se envía una solicitud GET a /api/appointments/user/{id}<br>**Then** el sistema debe devolver una lista de todas las citas asociadas a ese usuario<br><br>**Scenario:** Actualización o cancelación de una cita<br>**Given** un usuario autenticado con permisos sobre una cita existente<br>**When** se envía una solicitud PUT o DELETE a /api/appointments/{id} para actualizar el estado o cancelar la cita<br>**Then** el sistema debe procesar la solicitud (actualizar/cancelar) y devolver el código de estado HTTP apropiado (e.g., 200 OK, 204 No Content) | TS08 |
| TS09 | Integrar Servicio Externo para Notificaciones (e.g., WhatsApp/Twilio) | Como desarrollador, quiero integrar un servicio de mensajería externo (como la API de WhatsApp, Twilio, etc.), para permitir que el sistema envíe notificaciones automáticas y directas a los usuarios, mejorando la comunicación sobre sus citas y reparaciones. | **Scenario:** Envío de confirmación de cita<br>**Given** una cita ha sido confirmada exitosamente<br>**When** el sistema detecta la confirmación<br>**Then** se debe enviar automáticamente una notificación al número de WhatsApp registrado del usuario a través del servicio integrado<br><br>**Scenario:** Envío de recordatorios de cita<br>**Given** una cita se acerca a su fecha/hora programada<br>**When** el sistema ejecuta una tarea programada para enviar recordatorios<br>**Then** se debe enviar un mensaje de recordatorio al usuario a través del servicio integrado<br><br>**Scenario:** Gestión segura de credenciales del servicio externo<br>**Given** el sistema interactúa con el servicio de mensajería externo<br>**When** se utilizan las credenciales de autenticación<br>**Then** estas credenciales deben gestionarse de forma segura, similar a otras variables de entorno sensibles<br><br>**Scenario:** Manejo de errores de envío<br>**Given** un intento de enviar una notificación<br>**When** el servicio externo devuelve un error (e.g., número inválido, problema de credenciales)<br>**Then** el sistema debe registrar el error y manejarlo elegantemente (e.g., reintentar, notificar a un administrador) |  |
| TS10 | Establecer un Flujo Básico de CI/CD para Desarrollo y Despliegue | Como desarrollador, quiero establecer un flujo de Integración Continua (CI) y Despliegue Continuo (CD) básico, para automatizar las pruebas, la construcción y el despliegue de la aplicación, mejorando la eficiencia del desarrollo y reduciendo los errores manuales. | **Scenario:** Ejecución automática de pruebas unitarias y de integración<br>**Given** se realiza un push de código a la rama principal (e.g., main/master)<br>**When** el sistema de CI/CD detecta el cambio<br>**Then** debe ejecutar automáticamente todas las pruebas unitarias y de integración definidas<br><br>**Scenario:** Construcción automática de la aplicación<br>**Given** todas las pruebas automatizadas han pasado exitosamente<br>**When** el sistema de CI/CD procede a la siguiente etapa<br>**Then** debe construir la aplicación (generar artefactos del backend y/o frontend)<br><br>**Scenario:** Despliegue automatizado a entorno de staging<br>**Given** la construcción de la aplicación ha sido exitosa<br>**When** se aprueba la etapa de despliegue (puede ser manual o automático)<br>**Then** el artefacto debe ser desplegado automáticamente a un entorno de staging o pre-producción<br><br>**Scenario:** Configuración de entorno de desarrollo local<br>**Given** un nuevo miembro del equipo se une al proyecto<br>**When** necesita configurar su entorno de desarrollo<br>**Then** debe haber un proceso documentado y fácil de seguir para configurarlo<br><br>**Scenario:** Uso de control de versiones<br>**Given** cualquier cambio en el código fuente<br>**When** se desarrolla o se colabora en el proyecto<br>**Then** el repositorio de código debe estar configurado con un sistema de control de versiones (Git) |  |
| TS11 | Implementar Gestión de Roles y Permisos (RBAC) | Como desarrollador, quiero implementar un sistema de Control de Acceso Basado en Roles (RBAC), para garantizar que los usuarios (administradores de taller, mecánicos, clientes) solo puedan acceder a las funcionalidades y datos que les corresponden según su rol, mejorando la seguridad y la granularidad de los permisos. | **Scenario:** Asignación de roles a usuarios<br>**Given** un nuevo usuario se registra o se modifica un usuario existente<br>**When** se le asigna un rol específico (Cliente, Administrador de Taller, Mecánico)<br>**Then** el sistema debe almacenar el rol del usuario de forma persistente<br><br>**Scenario:** Acceso a funcionalidades basado en rol<br>**Given** un usuario autenticado con un rol determinado<br>**When** intenta acceder a una funcionalidad o recurso<br>**Then** el sistema debe verificar el rol del usuario<br>**And** debe permitir el acceso solo si el rol tiene los permisos necesarios<br><br>**Scenario:** Restricción de acceso a datos sensibles<br>**Given** un usuario con un rol limitado (e.g., Cliente, Mecánico)<br>**When** intenta ver o modificar datos sensibles que no le corresponden (e.g., finanzas del taller, perfiles de otros administradores)<br>**Then** el sistema debe denegar el acceso<br><br>**Scenario:** Gestión de permisos para nuevos roles<br>**Given** la necesidad de añadir un nuevo rol en el futuro<br>**When** se define el nuevo rol y sus permisos asociados<br>**Then** el sistema debe permitir configurar fácilmente qué funcionalidades y datos son accesibles para ese nuevo rol sin modificar el código base | |
| TS12 | Implementar Sistema de Notificaciones en la Aplicación | Como desarrollador, quiero implementar un sistema de notificaciones dentro de la aplicación, para que los usuarios reciban alertas sobre eventos importantes (e.g., cambio de estado de reparación, nueva cita agendada, recordatorios), mejorando la experiencia del usuario y la comunicación interna. | **Scenario:** Generación de notificación al cambiar el estado de reparación<br>**Given** el estado de una orden de reparación cambia (e.g., "Por revisar" a "En revisión")<br>**When** el cambio de estado se registra en el sistema<br>**Then** el sistema debe generar una notificación relevante para el cliente y/o el taller<br><br>**Scenario:** Visualización de notificaciones<br>**Given** un usuario ha recibido nuevas notificaciones<br>**When** el usuario accede a la sección de notificaciones de la aplicación<br>**Then** debe poder ver una lista de sus notificaciones, ordenadas cronológicamente<br><br>**Scenario:** Marcado de notificaciones como leídas<br>**Given** un usuario ha visto una notificación<br>**When** el usuario interactúa con ella (e.g., clic, deslizar)<br>**Then** la notificación debe marcarse como leída en el sistema<br>**And** el contador de notificaciones no leídas debe actualizarse<br><br>**Scenario:** Persistencia de notificaciones<br>**Given** un usuario recibe notificaciones<br>**When** el usuario cierra sesión y vuelve a iniciarla<br>**Then** sus notificaciones (leídas y no leídas) deben persistir |  |
| TS13 | Implementar Carga de Archivos Segura (Imágenes/Documentos) | Como desarrollador, quiero implementar una funcionalidad segura para la carga de archivos (imágenes de vehículos, documentos, etc.), para permitir a los usuarios adjuntar información relevante a reparaciones o perfiles de taller, garantizando la seguridad y el almacenamiento eficiente de los archivos. | **Scenario:** Carga exitosa de imágenes de vehículos<br>**Given** un usuario selecciona una imagen (JPG, PNG) para subir a una orden de reparación<br>**When** la imagen se envía al servidor<br>**Then** el sistema debe validar el tipo y tamaño del archivo<br>**And** almacenar la imagen de forma segura en un servicio de almacenamiento en la nube (e.g., S3, Google Cloud Storage)<br><br>**Scenario:** Prevención de carga de archivos maliciosos<br>**Given** un usuario intenta subir un archivo con un tipo no permitido (e.g., un ejecutable, un script)<br>**When** el archivo se envía al servidor<br>**Then** el sistema debe rechazar la carga y devolver un error apropiado<br><br>**Scenario:** Asociación de archivos con entidades<br>**Given** un archivo se sube exitosamente<br>**When** se guarda la referencia del archivo en la base de datos<br>**Then** el archivo debe estar correctamente asociado a la entidad correspondiente (e.g., repairCode, workshopId)<br><br>**Scenario:** Acceso a archivos cargados<br>**Given** un usuario con permisos para ver un recurso (e.g., una orden de reparación)<br>**When** accede al recurso que tiene archivos adjuntos<br>**Then** debe poder visualizar o descargar los archivos adjuntos |  |
| TS14 | Implementar Paginación y Filtrado Avanzado en Listados | Como desarrollador, quiero implementar funcionalidad de paginación y filtrado avanzado en los listados (e.g., talleres, citas, reparaciones), para mejorar el rendimiento de la aplicación y la experiencia del usuario al manejar grandes volúmenes de datos, permitiendo búsquedas más específicas. | **Scenario:** Paginación de resultados<br>**Given** un listado de elementos (e.g., 100 talleres)<br>**When** se solicita la página 1 con 10 elementos por página<br>**Then** la API debe devolver solo los primeros 10 elementos<br>**And** debe incluir metadatos de paginación (número total de elementos, página actual, total de páginas)<br><br>**Scenario:** Filtrado por múltiples criterios<br>**Given** un listado de elementos<br>**When** se envía una solicitud con múltiples parámetros de filtro (e.g., workshops?region=Lima&specialty=Mecanica)<br>**Then** la API debe devolver solo los elementos que cumplan todos los criterios especificados<br><br>**Scenario:** Ordenamiento de resultados<br>**Given** un listado de elementos<br>**When** se solicita el ordenamiento por un campo específico (e.g., workshops?sortBy=rating&order=desc)<br>**Then** la API debe devolver los elementos ordenados según el criterio<br><br>**Scenario:** Manejo de parámetros inválidos<br>**Given** una solicitud con parámetros de paginación, filtro u ordenamiento inválidos<br>**When** la API recibe la solicitud<br>**Then** debe devolver un error 400 Bad Request con un mensaje descriptivo | TS14 |
| TS15 | Optimizar Consultas a la Base de Datos para Rendimiento | Como desarrollador, quiero optimizar las consultas a la base de datos, especialmente las complejas o las que se ejecutan frecuentemente, para mejorar el tiempo de respuesta de la aplicación y asegurar una experiencia de usuario fluida, incluso bajo carga. | **Scenario:** Identificación de consultas lentas<br>**Given** la aplicación está bajo carga o se realizan operaciones comunes<br>**When** se monitorea el rendimiento de la base de datos<br>**Then** se deben identificar las consultas que tienen un tiempo de ejecución superior a un umbral definido<br><br>**Scenario:** Optimización de consultas identificadas<br>**Given** una consulta lenta identificada<br>**When** se refactoriza la consulta (e.g., ajustar índices, reescribir JOINs, usar EXPLAIN ANALYZE)<br>**Then** su tiempo de ejecución debe reducirse a un nivel aceptable<br><br>**Scenario:** Implementación de caché para datos frecuentemente accedidos<br>**Given** datos que se consultan con alta frecuencia y cambian poco (e.g., lista de especialidades)<br>**When** se accede a estos datos<br>**Then** el sistema debe utilizar un mecanismo de caché para reducir la carga de la base de datos y acelerar la respuesta<br><br>**Scenario:** Uso eficiente de ORM/SQL<br>**Given** la interacción con la base de datos a través de un ORM (si aplica)<br>**When** se realizan operaciones de lectura o escritura<br>**Then** se deben utilizar las funcionalidades del ORM de manera eficiente (e.g., eager loading, selección de campos específicos) o escribir SQL nativo optimizado |  |
| TS16 | Integrar Sistema de Pago (e.g., Stripe, OpenPay) | Como desarrollador, quiero integrar un sistema de pago seguro (como Stripe u OpenPay), para permitir a los talleres o clientes realizar transacciones económicas dentro de la plataforma de manera confiable y cumplir con los requisitos de seguridad de PCI DSS. | **Scenario:** Inicio de un proceso de pago<br>**Given** un usuario (e.g., taller pagando por un servicio premium, cliente pagando por una reparación)<br>**When** inicia una transacción de pago<br>**Then** el sistema debe interactuar de forma segura con la API del proveedor de pagos<br><br>**Scenario:** Procesamiento exitoso de un pago<br>**Given** los datos de pago válidos proporcionados por el usuario<br>**When** el pago es procesado por el proveedor externo<br>**Then** el sistema debe recibir una confirmación de pago exitosa<br>**And** debe actualizar el estado de la transacción en la base de datos<br><br>**Scenario:** Manejo de pagos fallidos<br>**Given** un intento de pago falla por cualquier motivo (e.g., tarjeta rechazada, datos incorrectos)<br>**When** el proveedor de pagos devuelve un error<br>**Then** el sistema debe registrar el error<br>**And** debe notificar al usuario de forma clara sobre el fallo y la razón (si es segura de mostrar)<br><br>**Scenario:** Cumplimiento de seguridad PCI<br>**Given** que la plataforma maneja información de tarjetas de crédito<br>**When** se integra el sistema de pagos<br>**Then** la implementación debe evitar que la información sensible de la tarjeta toque los servidores de la aplicación, delegando el manejo al proveedor certificado (PCI DSS)<br><br>**Scenario:** Webhooks para estados de pago<br>**Given** el proveedor de pagos notifica cambios en el estado de una transacción (e.g., reembolso, disputa)<br>**When** el sistema recibe el webhook<br>**Then** debe procesar la información y actualizar el estado de la transacción internamente |  |
| TS17 | Implementar Sistema de Reseñas y Calificaciones | Como desarrollador, quiero implementar un sistema de reseñas y calificaciones para los talleres, para que los clientes puedan compartir su experiencia y ayudar a otros usuarios a tomar decisiones informadas, y permitir a los talleres mejorar su servicio. | **Scenario:** Envío de una nueva reseña y calificación<br>**Given** un cliente ha completado una cita con un taller<br>**When** el cliente accede a la opción de dejar una reseña<br>**Then** debe poder enviar una calificación (e.g., 1-5 estrellas) y un comentario de texto<br><br>**Scenario:** Visualización de reseñas de un taller<br>**Given** un usuario accede a la página de detalle de un taller<br>**When** se muestra la información del taller<br>**Then** debe ver la calificación promedio del taller<br>**And** una lista de las reseñas individuales de los clientes<br><br>**Scenario:** Moderación de reseñas (opcional)<br>**Given** una reseña se envía<br>**When** la reseña contiene contenido inapropiado (si se implementa moderación)<br>**Then** no debe ser publicada o debe ser marcada para revisión por un administrador<br><br>**Scenario:** Cálculo de la calificación promedio del taller<br>**Given** un taller tiene múltiples reseñas<br>**When** se calcula su calificación promedio<br>**Then** debe reflejar con precisión el promedio de todas las calificaciones enviadas |  |
| TS19 | Implementar Envío de Emails Transaccionales (e.g., SendGrid, Mailgun) | Como desarrollador, quiero implementar el envío de emails transaccionales a través de un servicio externo (e.g., SendGrid, Mailgun), para enviar notificaciones importantes a los usuarios (e.g., confirmación de cuenta, recuperación de contraseña, resúmenes de cita) de manera confiable y escalable. | **Scenario:** Envío de email de confirmación de cuenta<br>**Given** un usuario completa el proceso de registro<br>**When** la cuenta es creada<br>**Then** el sistema debe enviar un email de confirmación de cuenta con un enlace de verificación<br><br>**Scenario:** Envío de email de recuperación de contraseña<br>**Given** un usuario solicita restablecer su contraseña<br>**When** la solicitud es válida<br>**Then** el sistema debe enviar un email con un enlace seguro para restablecer la contraseña<br><br>**Scenario:** Envío de resumen de cita<br>**Given** una cita ha sido confirmada o modificada<br>**When** la acción se registra<br>**Then** el sistema debe enviar un email al cliente con el resumen de la cita (fecha, hora, taller, vehículo, servicio)<br><br>**Scenario:** Manejo de plantillas de email<br>**Given** la necesidad de diferentes tipos de emails transaccionales<br>**When** se envían emails<br>**Then** el sistema debe utilizar plantillas predefinidas para cada tipo de email, personalizando el contenido dinámicamente<br><br>**Scenario:** Resistencia a fallos del servicio de email<br>**Given** el servicio de email externo experimenta una interrupción temporal<br>**When** el sistema intenta enviar un email<br>**Then** debe tener un mecanismo de reintento o de cola para asegurar que los emails se envíen eventualmente |  |
| TS20 | Refactorizar Módulo de Autenticación para Escalabilidad | Como desarrollador, quiero refactorizar el módulo de autenticación existente (TS-001) para mejorar su escalabilidad y mantenibilidad, para soportar un crecimiento futuro en el número de usuarios y facilitar la incorporación de nuevas estrategias de autenticación (e.g., SSO, OAuth) sin interrupciones mayores. | **Scenario:** Separación de responsabilidades<br>**Given** el código del módulo de autenticación actual<br>**When** se refactoriza<br>**Then** las responsabilidades de generación/validación de JWT, hashing de contraseñas y gestión de sesiones deben estar claramente separadas en diferentes componentes o servicios<br><br>**Scenario:** Pruebas unitarias completas<br>**Given** el módulo de autenticación refactorizado<br>**When** se ejecutan las pruebas<br>**Then** debe tener una cobertura de pruebas unitarias robusta que garantice su correcto funcionamiento<br><br>**Scenario:** Rendimiento bajo carga<br>**Given** el módulo de autenticación refactorizado<br>**When** se somete a pruebas de carga con un alto número de solicitudes de autenticación<br>**Then** debe mantener un tiempo de respuesta aceptable y una alta disponibilidad<br><br>**Scenario:** Facilidad de extensión<br>**Given** la necesidad de integrar un nuevo método de autenticación (e.g., "Login con Google")<br>**When** se extiende el módulo refactorizado<br>**Then** la nueva integración debe requerir cambios mínimos en el código existente<br><br>**Scenario:** Documentación de la arquitectura<br>**Given** el módulo de autenticación refactorizado<br>**When** se finaliza la refactorización<br>**Then** su nueva arquitectura y flujos clave deben estar claramente documentados |  |
















## 3.3. Impact Mapping

<img src="./src/Impact map 1.png " alt="Impact map 1" style="display: block; margin: 50px auto 0 auto;"/> 


## 3.4. Product Backlog
This section lists the prioritized product backlog items, including features, enhancements, and technical tasks.

## Product Backlog

| #Orden | User Story ID | Título | Descripción (resumen) | Story Points |
|--------|---------------|--------|-----------------------|--------------|
| 1 | **US01** | Registrar cuenta de gestor | Alta de usuario gestor (email, username únicos, pwd ≥ 6, bcrypt) | **5** |
| 2 | **US02** | Iniciar sesión | Autenticación (JWT) y ruteo a dashboard / onboarding | **3** |
| 3 | **US03** | Actualizar perfil personal | Cambiar firstname, lastname, username | **2** |
| 4 | **US04** | Cerrar sesión | Invalidar JWT y redirigir al login | **1** |
| 5 | **US05** | Registrar taller | Formulario completo + cascada Región → Ciudad + validaciones | **8** |
| 6 | **US06** | Editar taller | Actualizar datos del taller con autocompletado | **5** |
| 7 | **US07** | Configurar horarios | Crear calendario regular de atención con validaciones | **5** |
| 8 | **US08** | Actualizar horarios | Modificar o eliminar entradas de horario existentes | **3** |
| 9 | **US09** | Explorar talleres filtrados | Búsqueda por Región → Ciudad y cards de resultado | **5** |
| 10 | **US10** | Ver detalle de taller | Ficha completa + horarios + botón WhatsApp | **3** |
| 11 | **US11** | Registrar vehículo | Alta de vehículo (placa única, año válido) | **5** |
| 12 | **US12** | Listar vehículos | Cards de vehículos + botón “Crear reparación” | **3** |
| 13 | **US13** | Crear orden de reparación | Generar `repairCode` y estado inicial “Por revisar” | **8** |
| 14 | **US14** | Cambiar estado de reparación | Flujo Por revisar→En revisión→Revisado→Entregado con `updatedAt` | **5** |
| 15 | **US15** | Filtrar reparaciones | Lista filtrable por estado, respuesta ≤ 1 s | **3** |
| 16 | **US16** | Tracking de reparación (conductor) | Campo `repairCode`, validación y redirección | **3** |
| 17 | **US17** | Ver detalle de reparación | Estado + vehículo + taller + botón WhatsApp | **3** |


